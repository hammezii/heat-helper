{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"What is HEAT Helper?","text":"<p><code>heat-helper</code> is a Python utility library designed to streamline the cleaning and preparation of student data for use with the Higher Education Access Tracker (HEAT).</p> <p>Preparing CSV or Excel files for HEAT often involves repetitive tasks like cleaning and formatting of names, year groups, and postcodes. This package automates these common data-cleaning tasks to ensure your imports are valid and consistent. It also provides functions to help you match students to your existing HEAT records and get their IDs to support you in reducing duplicate records uploaded to the database and with registering students to activities.</p>"},{"location":"#features","title":"Features","text":"<p><code>heat_helper</code> provides functions to support many common tasks:</p> <ul> <li>Text Cleaning: simple functions to normalise names (including removing numbers, converting diacritics to plain text, removing punctuation except for hyphens and apostrophes, cleaning extra white spaces, and casing), postcodes, and year groups.</li> <li>Working with Dates: reverse day/month in a date, calculate a year group from date of birth, or calculate a date of birth range from year group</li> <li>Student Matching: exact and fuzzy match students from external sources (e.g. registers) to your HEAT Students export to get their ID numbers for activity linking.</li> <li>Data Validation: check dates of birth are in the right age range for a given year group, or check postcodes are in a UK format. Optionally install <code>pydantic</code> and generate error reports for your data.</li> <li>Bulk processing: get lists of Excel files in folders so you can process lots of files at once.</li> <li>Duplicates: find potential duplicates in a dataset based on name, date of birth and postcode.</li> <li>Compatibility: built for use with <code>pandas</code> for handling your data.</li> </ul>"},{"location":"#what-can-i-use-heat_helper-for","title":"What can I use heat_helper for?","text":"<p>Common use cases for <code>heat_helper</code> include:</p> <ul> <li>Cleaning new data to be uploaded to the HEAT database</li> <li>Checking if 'new' students already have records in HEAT</li> <li>Checking which fields need updating if students already have records in HEAT</li> <li>Matching students from your activities to their records on HEAT, so you can use their IDs to bulk register student records to activity records within HEAT</li> </ul>"},{"location":"#built-by","title":"Built by","text":"<p><code>heat_helper</code> was created by Hannah Merry at Higher Horizons Uni Connect and is free for anyone to use. It is open source, and you can find the code on Github.</p> <p>This documentation was built with material for mkdocs and mkdocstrings.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This page contains information about each release of <code>heat_helper</code>.</p>"},{"location":"changelog/#v012","title":"v0.1.2","text":"<p>Release date: 2026-02-13</p> <ul> <li>Bug Fix: fixed an error with the clean year group function which meant error behaviour wasn't working correctly when run on FE Levels.</li> </ul>"},{"location":"changelog/#v011","title":"v0.1.1","text":"<p>Release date: 2026-02-12</p> <p>First update to <code>heat_helper</code>. </p> <ul> <li>Data Validation: <code>pydantic</code> is now an optional dependency. This gives you access to a function which generates an error report by passing your data to a <code>pydantic</code> model. See usage documentation or API documentation.</li> <li>Bug fixes: <ul> <li>fixed some minor issues with the duplicates function which used incorrect variable names; </li> <li>improved error handling in name functions; </li> <li>added a length guard to format_postcode; </li> <li>update functions now copy the DataFrame rather than editing in place.</li> </ul> </li> <li>Optimisations: <ul> <li>improved column processing in convert_to_snake_case function; </li> <li>get_contextual_updates now takes any Iterable for bad_values (type hints and docs updated); </li> <li>adding column name variables used by matching functions as constants.</li> <li>duplicates function now has an optional twin_protection_threshold (default is 70);</li> <li>custom exceptions updated for clarity and consistency.</li> </ul> </li> <li>Documentation Improvements: reviewed docstrings and documentation for small errors, typos, and clarity and fixed all identified issues. </li> </ul>"},{"location":"changelog/#v010","title":"v0.1.0","text":"<p>Release date: 2026-01-16</p> <p>Initial release of <code>heat_helper</code>.</p>"},{"location":"cli/","title":"Command Line Interface","text":"<p><code>heat_helper</code> can be used from the command line for some simple cleaning, without having to write any python code.</p>"},{"location":"cli/#describe","title":"Describe","text":""},{"location":"cli/#clean","title":"Clean","text":""},{"location":"dates-doc/","title":"Dates API Reference","text":"<p>This is the API reference for all functions designed to be used on dates. You can find usage examples here.</p>"},{"location":"dates-doc/#heat_helper.dates.reverse_date","title":"hh.reverse_date","text":"<pre><code>reverse_date(input_date: date, errors: str = 'raise') -&gt; date\n</code></pre> <p>Sometimes dates are incorrectly formatted by Excel such that the day and month is swapped around. This can create errors when reading the data into pandas DataFrames. This function can be used to create a 'reversed' date where the day and month are swapped around. If this creates a date which doesn't exist, the original date is returned.</p> <p>Parameters:</p> Name Type Description Default <code>input_date</code> <code>date</code> <p>The date you wish to 'reverse' (swap day and month).</p> required <code>errors</code> <code>str</code> <p>Defaults to 'raise' which raises errors. 'ignore' ignores errors and returns original date.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised if input_date is not in the date format (or pandas datetime format.)</p> <p>Returns:</p> Name Type Description <code>date</code> <code>date</code> <p>Reversed date or original date if reversed date does not exist.</p>"},{"location":"dates-doc/#heat_helper.dates.calculate_dob_range_from_year_group","title":"hh.calculate_dob_range_from_year_group","text":"<pre><code>calculate_dob_range_from_year_group(\n    year_group: str | int | Series,\n    start_year: int = CURRENT_ACADEMIC_YEAR_START,\n    errors: str = \"raise\",\n) -&gt; tuple[date | None, date | None] | tuple[pd.Series, pd.Series]\n</code></pre> <p>Calculates the expected DOB range (Sep 1 to Aug 31) for a given year group (1 to 13) in England. Includes some logic to try to handle Reception if entered as 'Reception', 'R', or 'Year R'.</p> <p>Parameters:</p> Name Type Description Default <code>year_group</code> <code>str | int | Series</code> <p>The year group you want to find the date of birth range for. Examples: 'Year 10', 'Y10', 10. Note: Reception should be entered as Reception, Year R or R.</p> required <code>start_year</code> <code>optional</code> <p>The year in which the academic year starts for the academic year you want to calculate. Example: for 2025/2026 enter 2025. You can enter any year here and it will return the date of birth range for someone in that year group during the specified academic year. Default is start of current academic year.</p> <code>CURRENT_ACADEMIC_YEAR_START</code> <code>errors</code> <code>optional</code> <p>default = 'raise' which raises all errors. 'ignore' and 'coerce' returns None, None.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>InvalidYearGroupError</code> <p>Raised when <code>year_group</code> input cannot be parsed or is out of range.</p> <code>FELevelError</code> <p>Raised if FE Levels are in <code>year_group</code>.</p> <code>TypeError</code> <p>Raised if <code>year_group</code> cannot be parsed to a valid int.</p> <p>Returns:</p> Type Description <code>tuple[date | None, date | None] | tuple[Series, Series]</code> <p>The date of birth range. First date is start of the academic year; second date is the end of the academic year. Example: 01/09/2013, 31/08/2014.</p>"},{"location":"dates/","title":"Dates","text":"<p>These functions are designed for use on dates (usually dates of birth).</p>"},{"location":"dates/#reverse-dates","title":"Reverse Dates","text":"<p>This function can be used to 'reverse' the day and month in a date. This can be useful if Excel has incorrectly formatted a date and it has been read incorrectly by pandas. If the function would create a date which doesn't exist, the original date is returned. </p> <p>If <code>errors</code> are ignored for this function, original date is returned.</p> <p>Data Type Warning</p> <p>This function only works on dates - pandas DataFrame columns must be converted to datetime with <code>pd.to_datetime()</code> before being passed to this function.</p> Example with single dateExample with pandas DataFrame <pre><code>import heat_helper as hh\n\ndate_to_reverse = date(2025, 1, 2)\n\nprint(f\"Original date: {date_to_reverse}\")\n\ncheck = hh.reverse_date(date_to_reverse)\n\nprint(f\"Reversed date: {check}\")\n\n#Output: \n#Original date: 2025-01-02\n#Reversed date: 2025-02-01\n</code></pre> <pre><code>import heat_helper as hh\n\ndates = {'Dates' : [\n    '2025-01-02', \n    '2025-10-31', \n    '2025-11-03', \n    '2025-08-09', \n    '', \n    None]}\n\ndf = pd.DataFrame(dates)\n\ndf['Dates'] = pd.to_datetime(df['Dates'])\n\nprint(df.head(10))\n\ndf['Reversed'] = df['Dates'].apply(hh.reverse_date)\n\nprint(df.head(10))\n\n#Output: \n#       Dates   Reversed\n#0 2025-01-02 2025-02-01\n#1 2025-10-31 2025-10-31\n#2 2025-11-03 2025-03-11\n#3 2025-08-09 2025-09-08\n#4        NaT        NaT\n#5        NaT        NaT\n</code></pre>"},{"location":"dates/#calculate-date-of-birth-range-from-year-group","title":"Calculate Date of Birth Range from Year Group","text":"<p>This function calculates the date of birth range for a given year group. It returns a tuple of the start of the date of birth range (1st September (calculated year)) and the end of the date of birth range (31st August (calculated year)). It can calculate a date of birth range for any year group between Reception and Year 13. </p> <p>Error Warning</p> <p>This function cannot calculate date of birth ranges for FE Levels. It will raise <code>FELevelError</code> error if FE Levels are entered, or <code>InvalidYearGroupError</code> if a Year Group is outside of the expected range (0-13). If <code>errors</code> are ignored, a tuple of None, None is returned. You can set <code>error</code> behaviour using the errors argument.</p> Example with list of datesExample with pandas DataFrame <pre><code>import heat_helper as hh\n\nstart_date, end_date = hh.calculate_dob_range_from_year_group('Year 8')\n\nprint(f\n    \"Students in Year 8 have dates of birth between {start_date} and {end_date}\"\n    )\n\n# Output:\n# Students in Year 8 have dates of birth between 2012-09-01 and 2013-08-31\n</code></pre> <pre><code>import heat_helper as hh\nimport pandas as pd\nfrom datetime import date\n\n# Create example DataFrame\ndf_dict = {'Year Group' : ['Year 7', 8, 'Y9', 'year 10', 11, 'Year 12', \n                            'YEAR13', None, 'FE Level 3', 'Year 15']}\ndf = pd.DataFrame.from_dict(df_dict)\ndf['Year Group'] = df['Year Group'].astype(str)\n\n# Apply function\ndf['DOB Start'], df['DOB End'] = hh.calculate_dob_range_from_year_group(\n    df['Year Group'], errors='ignore')\nprint(df)\n\n#Output:\n#   Year Group   DOB Start     DOB End\n#      Year 7  2013-09-01  2014-08-31\n#           8  2012-09-01  2013-08-31\n#          Y9  2011-09-01  2012-08-31\n#     year 10  2010-09-01  2011-08-31\n#          11  2009-09-01  2010-08-31\n#     Year 12  2008-09-01  2009-08-31\n#      YEAR13  2007-09-01  2008-08-31\n#        None        None        None\n#  FE Level 3        None        None\n#     Year 15        None        None\n</code></pre>"},{"location":"duplicates-doc/","title":"Duplicates API Reference","text":"<p>This is the API reference for all functions designed to find duplicate records in a DataFrame. You can find usage examples here.</p>"},{"location":"duplicates-doc/#heat_helper.duplicates.find_duplicates","title":"hh.find_duplicates","text":"<pre><code>find_duplicates(\n    df: DataFrame,\n    name_col: str | list[str],\n    date_of_birth_col: str,\n    postcode_col: str,\n    id_col: str = None,\n    threshold: int = 80,\n    fuzzy_type: str = \"permissive\",\n    twin_protection: bool = True,\n    twin_protection_threshold: int = 70,\n) -&gt; pd.DataFrame\n</code></pre> <p>Attempts to find duplicate records within one DataFrame. The function looks for exact matches on any columns passed to name_col, date_of_birth_col and postcode_col, and then attempts to fuzzy match names using either date_of_birth_col or date_of_birth_col and postcode_col to create blocks of potential matches. Strictness of duplicate matching can be controlled using threshold (% match for fuzzy name matching), fuzzy type (permission or strict) which pools potential duplicates for matching by using either date of birth or date of birth and postcode, and setting twin_protection to True/False. Twin Protection isolates first names in potential matches to filter out people with totally different first names. This is not totally failsafe and may still return some twins as potential duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame contain records to check for duplicates.</p> required <code>name_col</code> <code>str | list[str]</code> <p>The column or list of columns contain names. Pass a list in the order the columns should be joined to create a full name e.g. ['First Name', 'Middle Name', 'Last Name'].</p> required <code>date_of_birth_col</code> <code>str</code> <p>The column containing date of birth.</p> required <code>postcode_col</code> <code>str</code> <p>The column containing postcode.</p> required <code>id_col</code> <code>str</code> <p>If there is already a column in your DataFrame which contains some kind of ID number, set it here. Otherwise, one will be created. Defaults to None.</p> <code>None</code> <code>threshold</code> <code>int</code> <p>The threshold for fuzzy matching. The percentage match of the name. Defaults to 80.</p> <code>80</code> <code>fuzzy_type</code> <code>str</code> <p>Controls whether date_of_birth_col or date_of_birth_col and postcode_col are used to create blocks for fuzzy matching. 'permissive' uses only date_of_birth_col, so will find duplicates with different postcodes. 'strict' uses both columns, so will only return potential duplicates where both date of birth and postcode match. Defaults to \"permissive\".</p> <code>'permissive'</code> <code>twin_protection</code> <code>bool</code> <p>If True, this filters out suspected twins with less similar first names (&lt;70% match) from returned potential duplicates. Defaults to True.</p> <code>True</code> <code>twin_protection_threshold</code> <code>int</code> <p>The threshold for first name matching when twin_protection is True. Defaults to 70.</p> <code>70</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised if df is not a DataFrame.</p> <code>ValueError</code> <p>Raised if threshold is not a value between 0 and 100 or if fuzzy_type is not 'strict' or 'permissive'.</p> <code>ColumnDoesNotExistError</code> <p>Raised if any of the columns passed as args are not in df.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame with a column called 'Potential Duplicates' which contains a list of IDs for any potential duplicates found by the function.</p>"},{"location":"duplicates/","title":"Duplicates","text":"<p>These functions help to find duplicates within your data.</p>"},{"location":"duplicates/#find-duplicates","title":"Find Duplicates","text":"<p>This function attempts to find duplicates within your data if given name, date of birth, and postcode. It first searches for exact matches and then looks for fuzzy name matches, using either date of birth and postcode or just date of birth, to limit the pool of potential matches. It returns a new column in your DataFrame called 'Potential Duplicates' which contains a list of ID numbers corresponding to the rows which are potential duplicates. If your data does not have a suitable column to use as the ID, one will be created by the function for you.</p>"},{"location":"duplicates/#controlling-for-similarity","title":"Controlling for Similarity","text":"<p>There are three ways to control the similarity of the duplicate matching. The first way is to set a fuzzy matching threshold. By default this is 80, but you can reduce it. It must be a number between 1 and 100 and roughly equates to the percentage match you are willing to accept when fuzzy matching names. </p> <p>The second way is to choose whether to use only date of birth, or date of birth and postcode to limit the pool of potential matches. If you set <code>fuzzy_type</code> to 'strict' it will only return potential duplicates where both date of birth and postcode match. By default it is set to 'permissive', which only matches on date of birth before attempting name matches. </p> <p>Finally you can toggle <code>twin_protection</code> to True or False. By default this is set to True. This compares first names only and excludes any matches where the first name is less than <code>twin_protection_threshold</code> (default is  70% but this can be customised). This assumes that genuine duplicates with nicknames or typos in first names will be over the specified threshold.</p> <p>Warning</p> <p>Twin protection is not foolproof and may still return some twins as potential duplicates or miss some students who are actual duplicates. In testing, turning this to True with a threshold of 70 reduced the twins being returned as duplicates by roughly 75%.</p> Example 1: No Twin ProtectionExample 2: Twin ProtectionExample 3: Fuzzy Type 'Strict' <pre><code>import heat_helper as hh\nimport pandas as pd\n\n# Example Data\n# Jane and Janie are duplicates \n# (she has moved house and has a different postcode)\n# Sarah and Sam are twins\n#\n# First Name       Last Name Date of Birth Home Postcode\n#       Jane             Doe    2010-01-01       AA1 1AA\n#      James           Smith    2011-02-02       BB2 2AB\n#      Janie             Doe    2010-01-01       AB1 1AB\n#      Sarah  Robinson-Jones    2008-03-03       CC3 3CC\n#        Sam  Robinson-Jones    2008-03-03       CC3 3CC\n\ndf = hh.find_duplicates(df,\n                    ['First Name', 'Last Name'],\n                    'Date of Birth',\n                    'Home Postcode',\n                    fuzzy_type='permissive',\n                    threshold=80,\n                    twin_protection=False\n                    )\n\n# Results: Jane and Janie, and Sarah and Sam, have flagged as duplicates\n#                                                                Potential\n# First Name       Last Name Date of Birth Home Postcode   ID   Duplicates\n#        Sam  Robinson-Jones    2008-03-03       CC3 3CC   #5       #4, #5\n#      Sarah  Robinson-Jones    2008-03-03       CC3 3CC   #4       #4, #5\n#      Janie             Doe    2010-01-01       AB1 1AB   #3       #1, #3\n#       Jane             Doe    2010-01-01       AA1 1AA   #1       #1, #3\n#      James           Smith    2011-02-02       BB2 2AB   #2         None\n</code></pre> <pre><code>import heat_helper as hh\nimport pandas as pd\n\n# Example Data\n# Jane and Janie are duplicates \n# (she has moved house and has a different postcode)\n# Sarah and Sam are twins\n#\n# First Name       Last Name Date of Birth Home Postcode\n#       Jane             Doe    2010-01-01       AA1 1AA\n#      James           Smith    2011-02-02       BB2 2AB\n#      Janie             Doe    2010-01-01       AB1 1AB\n#      Sarah  Robinson-Jones    2008-03-03       CC3 3CC\n#        Sam  Robinson-Jones    2008-03-03       CC3 3CC\n\ndf = hh.find_duplicates(df,\n                    ['First Name', 'Last Name'],\n                    'Date of Birth',\n                    'Home Postcode',\n                    fuzzy_type='permissive',\n                    threshold=80,\n                    twin_protection=True,\n                    twin_protection_threshold=75\n                    )\n\n# Results: Jane and Janie have flagged as duplicates\n# Sarah and Sam have been excluded because twin_protection is True and a custom twin_protection_threshold has been passed\n#                                                                Potential\n# First Name       Last Name Date of Birth Home Postcode   ID   Duplicates\n#      Janie             Doe    2010-01-01       AB1 1AB   #3       #1, #3\n#       Jane             Doe    2010-01-01       AA1 1AA   #1       #1, #3\n#        Sam  Robinson-Jones    2008-03-03       CC3 3CC   #5         None\n#      Sarah  Robinson-Jones    2008-03-03       CC3 3CC   #4         None\n#      James           Smith    2011-02-02       BB2 2AB   #2         None\n</code></pre> <pre><code>import heat_helper as hh\nimport pandas as pd\n\n# Example Data\n# Jane and Janie are duplicates \n# (she has moved house and has a different postcode)\n# Sarah and Sam are twins\n#\n# First Name       Last Name Date of Birth Home Postcode\n#       Jane             Doe    2010-01-01       AA1 1AA\n#      James           Smith    2011-02-02       BB2 2AB\n#      Janie             Doe    2010-01-01       AB1 1AB\n#      Sarah  Robinson-Jones    2008-03-03       CC3 3CC\n#        Sam  Robinson-Jones    2008-03-03       CC3 3CC\n\ndf = hh.find_duplicates(df,\n                    ['First Name', 'Last Name'],\n                    'Date of Birth',\n                    'Home Postcode',\n                    fuzzy_type='strict',\n                    threshold=80,\n                    twin_protection=True\n                    )\n\n# Results: No duplicates have been returned\n# Sarah and Sam have been excluded because twin_protection is True (with the default threshold of 70)\n# Jane and Janie have been excluded because they have different postcodes\n#                                                                 Potential\n# First Name       Last Name Date of Birth Home Postcode    ID   Duplicates\n#        Sam  Robinson-Jones    2008-03-03       CC3 3CC    #5         None\n#      Sarah  Robinson-Jones    2008-03-03       CC3 3CC    #4         None\n#      Janie             Doe    2010-01-01       AB1 1AB    #3         None\n#      James           Smith    2011-02-02       BB2 2AB    #2         None\n#       Jane             Doe    2010-01-01       AA1 1AA    #1         None\n</code></pre>"},{"location":"file-processing-doc/","title":"File Processing API Reference","text":"<p>This is the API reference for all functions designed to be files. You can find usage examples here.</p>"},{"location":"file-processing-doc/#heat_helper.utils.get_excel_filepaths_in_folder","title":"hh.get_excel_filepaths_in_folder","text":"<pre><code>get_excel_filepaths_in_folder(\n    input_dir: str, print_to_terminal: bool = False\n) -&gt; list[str]\n</code></pre> <p>Returns a list of filepaths to Excel files (with the extension .xlsx or .xls) in a given folder. Note: Only searches the top-level of input_dir; does not recursively search subdirectories.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>str</code> <p>The directory you want to get the filepaths from.</p> required <code>print_to_terminal</code> <code>optional</code> <p>Defaults to False. Set to True if you want the terminal to print messages about the file processing.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Raises errors if the directory does not exist.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of filepaths from the specified folder. Returns empty list if there are no Excel files in the folder.</p>"},{"location":"file-processing-doc/#heat_helper.utils.convert_col_snake_case","title":"hh.convert_col_snake_case","text":"<pre><code>convert_col_snake_case(df: DataFrame) -&gt; pd.DataFrame\n</code></pre> <p>Converts the column names of a DataFrame to snake case.  This function also checks for duplicate columns before and after conversion,  and raises a ColumnsNotUnique error if duplicates are found.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame you want to convert the column names of to snake case.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>Raises an error if the input is not a DataFrame.</p> <code>ColumnsNotUnique</code> <p>Raises an error if there are duplicate columns in the original DataFrame or if the snake-case conversion results in duplicate column names. The error message will specify which columns are duplicated</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A new DataFrame with the same data but with column names converted to snake case.</p>"},{"location":"file-processing/","title":"File Processing","text":"<p>These functions help you manipulate files.</p>"},{"location":"file-processing/#get-excel-filepaths-in-folder","title":"Get Excel Filepaths in Folder","text":"<p>This function will get a list of Excel files in a specified folder. This can be useful if you want to get data from multiple files at once and join these into one DataFrame. For example, if you have 10 separate activity registers from outreach activities and want to combine them into one DataFrame to allow you to match the students to your HEAT records. </p> <p>This function returns a list of filepaths, or an empty list if there are no files in the folder.</p> Example: simple usageExample: get register files to create master register <pre><code>import heat_helper as hh\n\nfolder_path = r\"C:\\path\\to\\registers\"\n\nfiles = hh.get_excel_filepaths_in_folder(folder_path)\n\nprint(files)\n\n# Output\n# [\"C:\\path\\to\\registers\\file1.xslx\", \n# \"C:\\path\\to\\registers\\file2.xslx\", \n# \"C:\\path\\to\\registers\\file3.xslx\"]\n</code></pre> <pre><code>import heat_helper as hh\n\nfolder_path = r\"C:\\path\\to\\registers\"\n\nfiles = hh.get_excel_filepaths_in_folder(folder_path)\n\n# Initialise empty loop to add the registers to\n# so you can join them together efficiently with pd.concat\nregister_files = []\nfor file in files:\n    reg = pd.read_excel(file, sheet_name=\"register\")\n    register_files.append(reg)\n\n# Join all files into one master DataFrame\nmaster_reg = pd.concat(register_files)\n</code></pre>"},{"location":"file-processing/#convert-columns-to-snake-case","title":"Convert Columns to Snake Case","text":"<p>This functions converts the column headers or titles in your DataFrame to snake case (e.g. 'First Name' -&gt; 'first_name'). This can be useful to help tidy data and normalise your headings by removing extra spaces, making them all lowercase, and by removing punctuation and special characters, or to make it easier to pass data to <code>pydantic</code> validation models. </p> <pre><code>print(f\"DataFrame columns names: {df.columns}\")\n\n# DataFrame columns names: Index(['First Name', 'Last Name', 'Date of Birth (dd/mm/yyyy)', 'Postcode'], dtype='object')\n\ndf = hh.convert_col_snake_case(df)\n\nprint(f\"DataFrame columns names after conversion: {df.columns}\")\n\n# DataFrame columns names after conversion: Index(['first_name', 'last_name', 'date_of_birth_ddmmyyyy', 'postcode'], dtype='object')\n</code></pre>"},{"location":"getting-help/","title":"Getting Help","text":"<p>If you are new to <code>heat_helper</code>, want to find out about its functions, or see examples of it in use, the following pages can help.</p>"},{"location":"getting-help/#usage-documentation","title":"Usage Documentation","text":"<p>The usage documentation contains an explanation of how each function works and examples of it in use. </p>"},{"location":"getting-help/#api-documentation","title":"API Documentation","text":"<p>The API documentation contains detailed information on the arguments of each function and datatypes it expects, as well as possible errors it can raise.</p>"},{"location":"getting-help/#github","title":"GitHub","text":"<p>Something not working as expected? You can raise an issue on GitHub.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p><code>heat_helper</code> is designed to be easy to use and to integrate with your python workflow, especially if you are already familiar with common data packages like <code>pandas</code>. </p>"},{"location":"getting-started/#importing-heat_helper-into-your-projects","title":"Importing heat_helper into your projects","text":"<p>Once installed, you can import <code>heat_helper</code>:</p> <pre><code>import heat_helper as hh\n</code></pre> <p>Then use any of the functions in the usage documentation.</p> <p>Example</p> <pre><code>import heat_helper as hh\n\nname = ' JANE    DoE '\nclean_name = hh.format_name(name)\nprint(clean_name)\n\n# Output: Jane Doe\n</code></pre>"},{"location":"getting-started/#using-cleaning-functions","title":"Using cleaning functions","text":"<p>Many <code>heat_helper</code> cleaning functions can be used on a column in a DataFrame by using the <code>pandas</code> <code>.apply()</code> method.</p> <p>Example</p> <pre><code>import heat_helper as hh\nimport pandas as pd\n\ndf = pd.read_csv('register.csv')\n\n# Create a new column containing the cleaned names\ndf['Clean Names'] = df['Names'].apply(hh.format_name, errors='ignore')\n\n# Output\n#             Names     Clean Names\n#          JANE DOE        Jane Doe\n#     jane      doe        Jane Doe\n#  Sarah - Jane Doe  Sarah-Jane Doe\n#          jane DOE        Jane Doe\n#   Sarah- Jane Doe  Sarah-Jane Doe\n#        jane mcdoe      Jane McDoe\n#        jane O'Doe      Jane O'Doe\n</code></pre>"},{"location":"getting-started/#example-cleaning-data-and-matching-to-heat","title":"Example: cleaning data and matching to heat","text":"<p>A simple scenario in which you might use <code>heat_helper</code> would be to clean activity registers and then match students to their HEAT records. This example assumes you have already loaded your CSV or Excel files as <code>df</code> (your register data) and <code>heat_df</code> (your HEAT student export).</p> <p>Example</p> <pre><code># You have collected the following register from an activity. \n# Because you were on the run from a Demogorgon on the way back \n# from the Upside Down, the data is a bit messy:\n\n#       Jane      Hopper    2000-01-01   AA1 1AA\n#       mike     Wheeler    2000-02-02   bb22bb\n#    Lucas.     Sinclair    2000-03-03   C33cc\n#    Robin 1     Buckley    1997-04-04   DD44DD\n#      steve  harrington    1997-05-05    E55EE\n#     dustin  HENDERSON     2000-06-06   F6 6FF\n\n# Clean the data\ndf['First Name'] = df['First Name'].apply(hh.format_name)\n                                    .apply(hh.remove_numbers)\n                                    .apply(hh.remove_punctuation)\n\ndf['Last Name'] = df['Last Name'].apply(hh.format_name)\n                                .apply(hh.remove_numbers)\n                                .apply(hh.remove_punctuation)\n\ndf['Postcode'] = df['Postcode'].apply(hh.format_postcode)\n\ndf['Date of Birth'] = pd.to_datetime(df['Date of Birth']).dt.normalize()\n\nprint(df)\n\n# The data now looks like this:\n\n# First Name   Last Name Date of Birth Postcode\n#       Jane      Hopper    2000-01-01  AA1 1AA\n#       Mike     Wheeler    2000-02-02  BB2 2BB\n#      Lucas    Sinclair    2000-03-03   C3 3CC\n#      Robin     Buckley    1997-04-04  DD4 4DD\n#      Steve  Harrington    1997-05-05   E5 5EE\n#     Dustin   Henderson    2000-06-06   F6 6FF\n\n# Now you want to match the records to HEAT. \n# You've been on crawls in the Upside Down before so\n# you know these students already have a record on \n# HEAT. You look for exact matches:\n\nmatched_df, unmatched_df = hh.perform_exact_match(\n    df, \n    heat_df, \n    ['First Name', 'Last Name', 'Date of Birth', 'Postcode'],\n    ['First Name', 'Last Name', 'Date of Birth', 'Postcode'],\n    \"Exact Match\")\n\nprint(matched_df)\n\n# This returns their HEAT IDs, which you can paste into your \n# HEAT upload template to register them to the activity:\n\n# First Name   Last Name Date of Birth Postcode     Match Type HEAT: HEAT ID\n#       Jane         Doe    2000-01-01  AA1 1AA  Exact Match           #1\n#       Mike     Wheeler    2000-02-02  BB2 2BB  Exact Match           #2\n#      Lucas    Sinclair    2000-03-03   C3 3CC  Exact Match           #3\n#      Robin     Buckley    1997-04-04  DD4 4DD  Exact Match           #4\n#      Steve  Harrington    1997-05-05   E5 5EE  Exact Match           #5\n#     Dustin   Henderson    2000-06-06   F6 6FF  Exact Match           #6\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>There are a few different options to install <code>heat_helper</code>. I recommend uv for easy package and project management. You can also install <code>heat_helper</code> with pip.</p> <p>To install <code>heat_helper</code> type either of the following into your terminal:</p> pipuv <pre><code>pip install heat_helper\n</code></pre> <pre><code>uv add heat_helper\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p><code>heat_helper</code> has the following dependencies which will also be installed:</p> <ul> <li><code>pandas</code> - for DataFrames and dealing with spreadsheet data</li> <li><code>rapidfuzz</code> - for fuzzy matching</li> <li><code>openpyxl</code> - for processing Excel files</li> </ul> <p>This means that in a new environment you can simply install <code>heat_helper</code> and have a complete setup for processing and manipulating CSV or Excel files.</p>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p><code>heat_helper</code> has the following optional dependencies:</p> <ul> <li><code>pydantic</code> - for data validation. If installed, you gain access to validation functions.</li> </ul> <p>To install <code>pydantic</code> use:</p> pipuv <pre><code>pip install heat_helper[validation]\n</code></pre> <pre><code>uv add heat_helper[validation]\n</code></pre>"},{"location":"installation/#install-from-respository","title":"Install from respository","text":"<p>If you have git installed on your system you can also install <code>heat_helper</code> directly from the GitHub repository:</p> pipuv <pre><code>pip install git+https://github.com/hammezii/heat-helper.git\n</code></pre> <pre><code>uv add git+https://github.com/hammezii/heat-helper.git\n</code></pre>"},{"location":"matching-doc/","title":"Matching API Reference","text":"<p>This is the API reference for all functions designed to help you match student data to HEAT records. You can find usage examples here.</p>"},{"location":"matching-doc/#heat_helper.matching.perform_exact_match","title":"hh.perform_exact_match","text":"<pre><code>perform_exact_match(\n    unmatched_df: DataFrame,\n    heat_df: DataFrame,\n    left_join_cols: list[str],\n    right_join_cols: list[str],\n    match_desc: str,\n    verify: bool = False,\n    heat_id_col: str = STUDENT_HEAT_ID,\n) -&gt; tuple[pd.DataFrame, pd.DataFrame]\n</code></pre> <p>Performs an exact match on specified columns between new data and your HEAT Student export and returns the HEAT Student ID if a match is found. This function returns two DataFrames: one containing the matches and one containing unmatched students, for passing to another matching function. This is useful to create a matching waterfall where you move through different levels of strictness.</p> <p>Parameters:</p> Name Type Description Default <code>unmatched_df</code> <code>DataFrame</code> <p>The DataFrame containing the students you want to search for.</p> required <code>heat_df</code> <code>DataFrame</code> <p>The DataFrame containing your HEAT Student Export.</p> required <code>left_join_cols</code> <code>list[str]</code> <p>Columns in new_df you want to match on.</p> required <code>right_join_cols</code> <code>list[str]</code> <p>Columns in heat_df you want to match on.</p> required <code>match_desc</code> <code>str</code> <p>A description of the match; added to a 'Match Type' col in the returned matched DataFrame. Should be descriptive to help you verify matches later, especially if joining multiple returns of this function and exporting to a .csv or Excel file.</p> required <code>verify</code> <code>optional</code> <p>Defaults to False. Controls whether to return all columns from heat_df to the matched DataFrame for verifying of matches. Useful if you are performing a less exact match and you want to verify the returned students. Also useful if you are using this function or perform_fuzzy_match function and want to join results together (column structure will be the same).</p> <code>False</code> <code>heat_id_col</code> <code>optional</code> <p>Defaults to 'Student HEAT ID'. Use this if the column in your HEAT Export with the Student ID in is not called 'Student HEAT ID'.</p> <code>STUDENT_HEAT_ID</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised if new_df or heat_df are not pandas DataFrames.</p> <code>ColumnDoesNotExistError</code> <p>Raised if a column you are trying to use for matching does not exist in either new_df or heat_df.</p> <p>Returns:</p> Type Description <code>tuple[DataFrame, DataFrame]</code> <p>Two DataFrames: first DataFrame is matched data, second is remaining data for onward matching.</p>"},{"location":"matching-doc/#heat_helper.matching.perform_fuzzy_match","title":"hh.perform_fuzzy_match","text":"<pre><code>perform_fuzzy_match(\n    unmatched_df: DataFrame,\n    heat_df: DataFrame,\n    left_filter_cols: list[str],\n    right_filter_cols: list[str],\n    left_name_col: str,\n    right_name_col: str,\n    match_desc: str,\n    threshold: int = 80,\n) -&gt; tuple[pd.DataFrame, pd.DataFrame]\n</code></pre> <p>This function allows you to fuzzy match names of students in an external dataset to your HEAT Student Export to retrieve HEAT Student IDs. You can control the potential pool of fuzzy matches by specifying filter columns in both DataFrames e.g. only look for fuzzy matches where Date of Birth and Postcode matches. Note: there may be performance issues with very large datasets. If you have a large dataset, it is recommended to first use perform_exact_match to pull out exact matches and reduce the dataset before using this function for fuzzy matching.</p> <p>Parameters:</p> Name Type Description Default <code>unmatched_df</code> <code>DataFrame</code> <p>The DataFrame of students you want to fuzzy match.</p> required <code>heat_df</code> <code>DataFrame</code> <p>The DataFrame containing your HEAT Student Export.</p> required <code>left_filter_cols</code> <code>list[str]</code> <p>Filter columns in unmatched_df. By specifying a column here it will be used to control the pool of possible fuzzy matches. For example, by setting Date of birth and postcode here, it will only fuzzy match 'Jo Smith' to 'Joanne Smith' if both records have the same date of birth and postcode.</p> required <code>right_filter_cols</code> <code>list[str]</code> <p>Corresponding filter columns in heat_df. Must match those set in left_filter_cols.</p> required <code>left_name_col</code> <code>str</code> <p>Column which contains the name information (to be matched) in unmatched_df.</p> required <code>right_name_col</code> <code>str</code> <p>Column which contains the name information in heat_df.</p> required <code>match_desc</code> <code>str</code> <p>A description of the match; added to a 'Match Type' col in the returned matched DataFrame. Should be descriptive to help you verify matches later, especially if joining multiple returns of this function and exporting to a .csv or Excel file.</p> required <code>threshold</code> <code>optional</code> <p>The acceptable percentage match for fuzzy matching. Higher is stricter and matches will be more similar. Defaults to 80.</p> <code>80</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised if unmatched_df or heat_df are not pandas DataFrames.</p> <code>ColumnDoesNotExistError</code> <p>Raised if columns specified as filters or name columns do not exist in their DataFrames.</p> <code>FilterColumnMismatchError</code> <p>Raised if unequal number of columns specified in left and right filters.</p> <code>FuzzyMatchIndexError</code> <p>Raised when unmatched_df does not have a unique index and cannot be used for matching.</p> <p>Returns:</p> Type Description <code>tuple[DataFrame, DataFrame]</code> <p>Two DataFrames: first DataFrame is matched data, second is remaining data for onward matching.</p>"},{"location":"matching-doc/#heat_helper.matching.perform_school_age_range_fuzzy_match","title":"hh.perform_school_age_range_fuzzy_match","text":"<pre><code>perform_school_age_range_fuzzy_match(\n    unmatched_df: DataFrame,\n    heat_df: DataFrame,\n    unmatched_school_col: str,\n    heat_school_col: str,\n    unmatched_name_col: str,\n    heat_name_col: str,\n    unmatched_year_group_col: str,\n    heat_dob_col: str,\n    match_desc: str,\n    heat_id_col: str = STUDENT_HEAT_ID,\n    academic_year_start: int = CURRENT_ACADEMIC_YEAR_START,\n    threshold: int = 80,\n) -&gt; tuple[pd.DataFrame, pd.DataFrame]\n</code></pre> <p>This function attempts to fuzzy match the names of students to your HEAT data. To control the pool of fuzzy matches, data is first matched on school name, and then uses year group to only return students with a date of birth in range for that year group. Useful if you do not know a student's date of birth, but you do know which school they attend and their year group. Returns one dataframe of matches and one dataframe of remaining unmatched data. Note: there may be performance issues with very large datasets. If you have a large dataset, it is recommended to first use perform_exact_match to pull out exact matches and reduce the dataset before using this function for fuzzy matching.</p> <p>Parameters:</p> Name Type Description Default <code>unmatched_df</code> <code>DataFrame</code> <p>DataFrame containing student records you wish to fuzzy match to HEAT records.</p> required <code>heat_df</code> <code>DataFrame</code> <p>DataFrame containing HEAT Student Export.</p> required <code>unmatched_school_col</code> <code>str</code> <p>Column which contains School name in unmatched_df.</p> required <code>heat_school_col</code> <code>str</code> <p>Column which contains school name in heat_df.</p> required <code>unmatched_name_col</code> <code>str</code> <p>Column which contains Student name in unmatched_df.</p> required <code>heat_name_col</code> <code>str</code> <p>Column which contains Student name in heat_df.</p> required <code>unmatched_year_group_col</code> <code>str</code> <p>Column in unmatched_df which contains year group for age range calculation.</p> required <code>heat_dob_col</code> <code>str</code> <p>Column in heat_df which contains Student Date of Birth.</p> required <code>match_desc</code> <code>str</code> <p>A description of the match; added to a 'Match Type' col in the returned matched DataFrame. Should be descriptive to help you verify matches later, especially if joining multiple returns of this function and exporting to a .csv or Excel file.</p> required <code>heat_id_col</code> <code>optional</code> <p>Column in heat_df which contains HEAT Student ID. Defaults to 'Student HEAT ID'.</p> <code>STUDENT_HEAT_ID</code> <code>academic_year_start</code> <code>optional</code> <p>. Defaults to start of current academic year (calculated by package).</p> <code>CURRENT_ACADEMIC_YEAR_START</code> <code>threshold</code> <code>optional</code> <p>The acceptable percentage match for fuzzy matching. Higher is stricter and matches will be more similar. Defaults to 80.</p> <code>80</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised if unmatched_df or heat_df are not pandas DataFrames or if heat_dob_col is not in pandas Datetime format (will try to convert first.)</p> <code>ColumnDoesNotExistError</code> <p>Raised if any specified column does not exist in its dataframe.</p> <code>FuzzyMatchIndexError</code> <p>Raised if unmatched_df does not have unique index.</p> <p>Returns:</p> Type Description <code>tuple[DataFrame, DataFrame]</code> <p>Two DataFrames: first DataFrame is matched data, second is remaining data for onward matching.</p>"},{"location":"matching/","title":"Matching","text":"<p>These functions are used to match student data to your HEAT records using the Student Export. They can be used to check if students in newly collected data already have records or to find Student IDs for registering students to activities within HEAT.</p>"},{"location":"matching/#perform-exact-match","title":"Perform Exact Match","text":"<p>This function is used to exactly match student data to records in your HEAT Student Export. It uses the <code>pandas</code> <code>merge</code> function, which joins two DataFrames on common columns. You can use any number of columns to perform the join, but the number of columns passed to <code>left_join_cols</code> and <code>right_join_cols</code> must match. You can choose to return just the HEAT IDs from the HEAT export, or all columns in your HEAT Sudent Export using the <code>verify</code> argument. </p> <p>Tip</p> <p>If you want to return all columns from your Student Export you may wish to drop some columns from the DataFrame before you use this function, as the resulting DataFrame may have a higher number of columns. For example, you might only wish to include columns needed to verify the match, or ones which you might want to check for updates if you're using this function on new data you want to upload to HEAT.</p> <p>This function returns two DataFrames: one containing your matches, and one containing remaining student data which was not matched in its original format. This can be used for matching again, for example by using this function again with less strict criteria, or by using any other matching functions. The DataFrame containing your matches includes a column called 'Match Type' populated with whatever text you passed to <code>match_desc</code>. This can be useful if you join results of multiple matching functions together to one DataFrame to verify later: it helps you identify which matches were returned by which functions.</p> <p>Note</p> <p>The function assumes the column in the HEAT export with the IDs in is called 'Student HEAT ID'. If for any reason your column is not called this, you should set the name by passing a value to the optional <code>heat_id_col</code> argument. See API documentation.</p> Example with pandas DataFrames <pre><code>import heat_helper as hh\nfrom datetime import date\nimport pandas as pd\n\nprint(f\"------ NEW DATA\")\nprint(new_data)\nprint(f\"------ HEAT DATA\")\nprint(heat)\n\nprint(f\"------ STARTING MATCH\")\nmatched, unmatched = hh.perform_exact_match(\n    new_data,\n    heat,\n    ['Full Name', 'Date of Birth', 'Postcode'],\n    ['Student Full Name', 'Student Date of Birth', 'Student Postcode'],\n    'Exact match',\n    student_heat_id_col='ID'\n)\n\nprint(f\"------ MATCHED DATA\")\nprint(matched)\nprint(f\"------ UNMATCHED DATA\")\nprint(unmatched)\n\n# Output\n#------ NEW DATA\n#      Full Name Date of Birth Postcode\n#0      Jane Doe    2008-09-02  AA1 1AA\n#1  Thomas Smith    2008-12-25  CC3 3CC\n#2    Mike Jones    2009-07-25  BB2 2BB\n#3   Sarah Brown    2008-11-13  DD4 4DD\n#\n#------ HEAT DATA\n#          ID Student Full Name Student Date of Birth Student Postcode  \n#0  #00000001          Jane Doe            2008-09-02          AA1 1AA\n#1  #00000002     Michael Jones            2009-07-25          BB2 2BB\n#2  #00000003      Thomas Smith            2008-12-25          CC3 3CC\n#3  #00000004       Sarah Brown            2008-11-13          DD4 4DD\n#4  #00000005          Jane Doe            2008-09-02          AA1 1AA\n#\n#------ STARTING MATCH\n#   Attempting match: Exact match:\n#     ...3 students found in HEAT data\n#     ...1 students left to find.\n#     WARNING: 1 extra record(s) created. Some student matched to multiple \n#       HEAT records. Check HEAT data for duplicates.\n#\n#------ MATCHED DATA\n#      Full Name Date of Birth Postcode         ID   Match Type\n#0      Jane Doe    2008-09-02  AA1 1AA  #00000001  Exact match\n#1      Jane Doe    2008-09-02  AA1 1AA  #00000005  Exact match\n#2  Thomas Smith    2008-12-25  CC3 3CC  #00000003  Exact match\n#3   Sarah Brown    2008-11-13  DD4 4DD  #00000004  Exact match\n#\n#------ UNMATCHED DATA\n#    Full Name Date of Birth Postcode\n#0  Mike Jones    2009-07-25  BB2 2BB\n</code></pre>"},{"location":"matching/#perform-fuzzy-match","title":"Perform Fuzzy Match","text":"<p>This function uses fuzzy matching on student names to find students in your HEAT Student Export. In order to improve the likelihood of matches, the function uses any number of columns to filter the pool of possible matches, and then returns the best match from this pool. It only returns one match (the best match) per student in your new DataFrame.</p> <p>Tip</p> <p>Unlike the exact match function above, this function returns all columns from the HEAT Student Export as it assumes you will need to verify the matches. This means the resulting DataFrame may have a high number of columns. You might wish to drop some columns from your HEAT Student Export before using this function. For example, you might only wish to include columns needed to verify the match, or ones which you might want to check for updates if you're using this function on new data you want to upload to HEAT.</p> <p>You can control the strictness of the match with the <code>threshold</code> argument. This defaults to 80, but you may want to experiment with different values depending on how many columns you are using to control the match pool. If you are only looking for name fuzzy matches where Date of Birth and Postcode matches, you could lower the threshold to 70, as there will be a limited pool of potential matches, for example.</p> <p>Warning</p> <p>Before using this function you must create a column in both DataFrames which contains the students' full names. You can use the create full name function to do this.</p> <p>This function returns two DataFrames: one containing your matches, and one containing remaining student data which was not matched in its original format. This can be used for matching again, for example by using this function again with less strict criteria, or by using any other matching function.</p> <p>The matches DataFrame includes a column called Fuzzy Score which tells you the percentage match between the names. Higher means the names are more similar. 100 means the names match exactly. It also includes a column called 'Match Type' populated with whatever text you passed to <code>match_desc</code>. This can be useful if you join results of multiple matching functions together to one DataFrame to verify later: it helps you identify which matches were returned by which functions.</p> <p>Warning</p> <p>This function uses iterative processing and may be slow for datasets with &gt;10,000 rows. Consider testing with a sample first, or removing exact matches using <code>perform_exact_match</code> before you attempt fuzzy matching.</p> Example with pandas DataFrame <pre><code>import heat_helper as hh\nfrom datetime import date\nimport pandas as pd\n\nprint(f\"------ NEW DATA\")\nprint(new_data)\nprint(f\"------ HEAT DATA\")\nprint(heat)\n\nprint(f\"------ STARTING MATCH\")\nmatched, unmatched = hh.perform_fuzzy_match(\n    new_data,\n    heat,\n    ['Date of Birth', 'Postcode'],\n    ['Student Date of Birth', 'Student Postcode'],\n    'Full Name',\n    'Student Full Name',\n    'Fuzzy Name DOB+Postcode match',\n    threshold=70,\n)\n\nprint(f\"------ MATCHED DATA\")\nprint(matched)\nprint(f\"------ UNMATCHED DATA\")\nprint(unmatched)\n\n# Output\n#------ NEW DATA\n#            Full Name Date of Birth Postcode\n#0            Jane Doe    2008-09-02  AA1 1AA\n#1          Mike Jones    2009-07-25  BB2 2BB\n#2        Thomas Smith    2008-12-25  CC3 3CC\n#3         Sarah Brown    2008-11-13  DD4 4DD\n#4  Christopher Bloggs    2010-12-30  EE5 5EE\n#\n#------ HEAT DATA\n#        ID     Student Full Name Student Date of Birth  Student Postcode\n#0  #00000001          Jane Doe            2008-09-02          AA1 1AA\n#1  #00000002     Michael Jones            2009-07-25          BB2 2BB\n#2  #00000003      Thomas Smith            2008-12-25          CC3 3CC\n#3  #00000004       Sarah Brown            2008-11-13          DD4 4DD\n#4  #00000005          Jane Doe            2008-09-02          AA1 1AA\n#5  #00000006  Sarah Jane Brown            2008-11-13          DD4 4DD\n#\n#------ STARTING MATCH\n#Attempting fuzzy match where ['Date of Birth', 'Postcode'] match HEAT data.\n#    ...4 students found in HEAT data.\n#    ...1 students left to find.\n#\n#------ MATCHED DATA\n#      Full Name Date of Birth Postcode  ... Fuzzy Score  Match Type\n#0      Jane Doe    2008-09-02  AA1 1AA  ...      100.00  Fuzzy Name DOB+Postcode match\n#1  Thomas Smith    2008-12-25  CC3 3CC  ...      100.00  Fuzzy Name DOB+Postcode match\n#2   Sarah Brown    2008-11-13  DD4 4DD  ...      100.00  Fuzzy Name DOB+Postcode match\n#3    Mike Jones    2009-07-25  BB2 2BB  ...       78.26  Fuzzy Name DOB+Postcode match\n#\n#------ UNMATCHED DATA\n#            Full Name Date of Birth Postcode\n#4  Christopher Bloggs    2010-12-30  EE5 5EE\n</code></pre>"},{"location":"matching/#perform-school-age-range-fuzzy-match","title":"Perform School Age Range Fuzzy Match","text":"<p>This function fuzzy matches student names to your HEAT Export by grouping potential matches by school and year group. It is particularly useful if you do not have a student date of birth but you do know which year group they are in. The function uses year group to create a date of birth range to search within from the student's school.</p> <p>Tip</p> <p>You can either use School Name or School ID to group students by school, but you should ensure that the data you are trying to match to your HEAT Student Export contains school names or IDs exactly as they appear on HEAT, or the function will not work.</p> <p>You can control the strictness of the match with the <code>threshold</code> argument. This defaults to 80, but you may want to experiment with different values depending on how strict you want the fuzzy match to be.</p> <p>Warning</p> <p>Before using this function you must create a column in both DataFrames which contains the students' full names. You can use the create full name function to do this.</p> <p>This function returns two DataFrames: one containing your matches, and one containing remaining student data which was not matched in its original format. This can be used for matching again, for example by using this function again with less strict criteria, or by using any other matching function.</p> <p>Warning</p> <p>This function uses iterative processing and may be slow for datasets with &gt;10,000 rows. Consider testing with a sample first, or removing exact matches using <code>perform_exact_match</code> before you attempt fuzzy matching.</p> <p>The matches DataFrame includes a column called Fuzzy Score which tells you the percentage match between the names. Higher means the names are more similar. 100 means the names match exactly. It also includes a column called 'Match Type' populated with whatever text you passed to <code>match_desc</code>. This can be useful if you join results of multiple matching functions together to one DataFrame to verify later: it helps you identify which matches were returned by which functions.</p> <p>Note</p> <p>The function assumes the column in the HEAT export with the IDs in is called 'Student HEAT ID'. If for any reason your column is not called this, you should set the name by passing a value to the <code>heat_id_col</code> argument. See API documentation.</p> Example with pandas DataFrame <pre><code>import heat_helper as hh\nimport pandas as pd\n\nmatched_df, unmatched_df = hh.perform_school_age_range_fuzzy_match(\nnew,\nheat,\n'School',\n'Student School',\n'Full Name',\n'Student Full Name',\n'Year Group',\n'Student Date of Birth',\n'DOB In Range for YG',\nheat_id_col = 'ID'\n)\n\n#---- NEW DATA\n#           Full Name Postcode    School Year Group\n#            Jane Doe  AA1 1AA  School A    Year 12\n#          Mike Jones  BB2 2BB  School A    Year 12\n#        Thomas Smith  CC3 3CC  School A    Year 12\n#         Sarah Brown  DD4 4DD  School B    Year 12\n#  Christopher Bloggs  EE5 5EE  School B    Year 10\n#\n#---- HEAT DATA\n#           ID         Full Name Date of Birth Postcode    School\n#  #00000001         Janie Doe    2008-09-02  AA1 1AA  School A\n#  #00000002     Michael Jones    2009-07-25  BB2 2BB  School A\n#  #00000003      Thomas Smith    2008-12-25  CC3 3CC  School A\n#  #00000004       Sarah Brown    2008-11-13  DD4 4DD  School B\n#  #00000005          Jane Doe    2008-09-02  AA1 1AA  School B\n#  #00000006  Sarah Jane Brown    2008-11-13  DD4 4DD  School A\n#\n#---- MATCHED DATA\n#  Full Name Postcode    School Year Group   HEAT: ID HEAT: Full Name HEAT: Date of Birth HEAT: Postcode HEAT: School  Fuzzy Score           Match Type\n#  Thomas Smith  CC3 3CC  School A    Year 12  #00000003    Thomas Smith          2008-12-25        CC3 3CC     School A       100.00  DOB In Range for YG\n#   Sarah Brown  DD4 4DD  School B    Year 12  #00000004     Sarah Brown          2008-11-13        DD4 4DD     School B       100.00  DOB In Range for YG\n#      Jane Doe  AA1 1AA  School A    Year 12  #00000001       Janie Doe          2008-09-02        AA1 1AA     School A        94.12  DOB In Range for YG\n#\n#---- UNMATCHED DATA\n#           Full Name Postcode    School Year Group\n#          Mike Jones  BB2 2BB  School A    Year 12\n#  Christopher Bloggs  EE5 5EE  School B    Year 10\n</code></pre>"},{"location":"names-doc/","title":"Names API Reference","text":"<p>This is the API reference for all functions designed to be used on names. You can find usage examples here.</p>"},{"location":"names-doc/#heat_helper.names.format_name","title":"hh.format_name","text":"<pre><code>format_name(text: str, errors: str = 'raise') -&gt; str | None\n</code></pre> <p>Cleans the formatting of names. Strips extra whitespaces, converts to title case (with exceptions for names like McDonald and O'Reilly) and tidies any spaces around hyphens.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The name you wish to clean.</p> required <code>errors</code> <code>optional</code> <p>Default = 'raise' which raises all errors. 'ignore' ignores errors and returns original value, 'coerce' returns None.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised if text is not a string.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>Cleaned text.</p>"},{"location":"names-doc/#heat_helper.names.create_full_name","title":"hh.create_full_name","text":"<pre><code>create_full_name(\n    first_name: str | Series,\n    last_name: str | Series,\n    middle_name: str | Series = \"\",\n) -&gt; str | pd.Series\n</code></pre> <p>Joins strings or pandas DataFrame columns into a 'Full Name' string or column of strings. Useful if you are going to be fuzzy matching names.</p> <p>Parameters:</p> Name Type Description Default <code>first_name</code> <code>str | Series</code> <p>First name.</p> required <code>last_name</code> <code>str | Series</code> <p>Last name.</p> required <code>middle_name</code> <code>optional</code> <p>Middle name. Defaults to a blank string or blank pd.Series.</p> <code>''</code> <p>Returns:</p> Type Description <code>str | Series</code> <p>One string or Series of strings with all names joined.</p>"},{"location":"names-doc/#heat_helper.names.find_numbers_in_text","title":"hh.find_numbers_in_text","text":"<pre><code>find_numbers_in_text(\n    text: str, errors: str = \"raise\", convert_to_string: bool = False\n) -&gt; bool | str | None\n</code></pre> <p>Checks if one or more numbers are present in a string. Numbers do not have to be consecutive.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to check for numbers.</p> required <code>errors</code> <code>optional</code> <p>Default = 'raise' which raises all errors. 'ignore' ignores errors and returns original value, 'coerce' returns None.</p> <code>'raise'</code> <code>convert_to_string</code> <code>optional</code> <p>Tells the function to convert text datatype to string, if possible. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised if text datatype is not string.</p> <p>Returns:</p> Type Description <code>bool | str | None</code> <p>True if string contains one or more numbers (0-9) or False if no numbers present.</p>"},{"location":"names-doc/#heat_helper.names.remove_numbers","title":"hh.remove_numbers","text":"<pre><code>remove_numbers(\n    text: str, errors: str = \"raise\", convert_to_string: bool = False\n) -&gt; str | None\n</code></pre> <p>Removes one or more numbers from a string (text). Numbers do not have to be consecutive.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The string you want to remove numbers from e.g. 'Jane Doe 43'</p> required <code>errors</code> <code>optional</code> <p>Default = 'raise' which raises all errors. 'ignore' ignores errors and returns original value, 'coerce' returns None.</p> <code>'raise'</code> <code>convert_to_string</code> <code>optional</code> <p>Tells the function to convert text datatype to string, if possible. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised if text is not a string.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>Text with numbers removed.</p>"},{"location":"names-doc/#heat_helper.names.remove_diacritics","title":"hh.remove_diacritics","text":"<pre><code>remove_diacritics(\n    input_text: str, errors: str = \"raise\"\n) -&gt; str | None\n</code></pre> <p>Removes diacritics (accented letters) from text. Uses python's built-in unicodedata library and normalises to NFKD before removal.</p> <p>Parameters:</p> Name Type Description Default <code>input_text</code> <code>str</code> <p>The text you want to remove diacritics from.</p> required <code>errors</code> <code>optional</code> <p>Default = 'raise' which raises all errors. 'ignore' ignores errors and returns original value, 'coerce' returns None.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised if input_text is not a string.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>Text with accents removed e.g. 'Chloe\u0308' -&gt; 'Chloe'.</p>"},{"location":"names-doc/#heat_helper.names.remove_punctuation","title":"hh.remove_punctuation","text":"<pre><code>remove_punctuation(\n    text: str, punctuation: str = PUNCTUATION, errors: str = \"raise\"\n) -&gt; str | None\n</code></pre> <p>Removes all punctuation except for hyphens and apostrophes from text. Useful for cleaning names.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text you wish to remove punctuation from.</p> required <code>punctuation</code> <code>optional</code> <p>String containing all punctuation except for hyphens and apostrophes. Can be overridden with your own version if you want to exclude other types of punctuation. Should be one string of all chars to remove. Default includes the following chars: !@#\u00a3$%^&amp;*()_=+`~,.&lt;&gt;/?;:\"|[]</p> <code>PUNCTUATION</code> <code>errors</code> <code>optional</code> <p>Default = 'raise' which raises all errors. 'ignore' ignores errors and returns original value, 'coerce' returns None.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised if text is not a string.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>Text with all punctuation except hyphens and apostrophes removed e.g. 'Jane! Doe.' -&gt; 'Jane Doe'</p>"},{"location":"names/","title":"Names and Text","text":"<p>These functions are used to help you clean and format student names.</p>"},{"location":"names/#format-name","title":"Format Name","text":"<p>This function takes text (names) and cleans them. It carries out a number of common cleaning steps:</p> <ul> <li>changes to title case (with exceptions for names like McDonald and O'Reilly),</li> <li>removes any number of spaces either side of hyphens,</li> <li>cleans instances of more than one space and changes it to a single space,</li> <li>cleans leading or trailing whitespace.</li> </ul> <p>Info</p> <p>You can pass the <code>errors</code> argument to control error behaviour. Default is 'raise' which will raise all errors and stop your script. 'ignore' will not raise an error and return the original value. 'coerce' will not raise an error and return None.</p> <p>To use the errors argument when passing to a pandas dataframe use:  <code>df['Clean Names'] = df['Names'].apply(hh.format_name, errors='ignore')</code></p> Clean one nameClean a list of namesClean a pandas DataFrame column <pre><code>import heat_helper as hh\n\n# Example: clean one name\nname = ' JANE    DoE '\nclean_name = hh.format_name(name)\nprint(clean_name)\n\n#Output: Jane Doe\n</code></pre> <pre><code>import heat_helper as hh\n\nmessy_names = [\"JANE DOE\", \n            \"jane      doe\", \n            \"jane DOE\", \n            \"Sarah - Jane Doe \", \n            \" Sarah- Jane Doe\", \n            \"jane mcdoe\", \n            \"jane O'Doe\"]\n\nclean_names = [hh.format_name(name) for name in messy_names]\n\nprint(clean_names)\n\n# Output: \n# [\"Jane Doe\", \n# \"Jane Doe\", \n# \"Jane Doe\", \n# \"Sarah-Jane Doe\", \n# \"Sarah-Jane Doe\", \n# \"Jane McDoe\", \n# \"Jane O'Doe\"]\n</code></pre> <pre><code>import heat_helper as hh\nimport pandas as pd\n\nmessy_names = {'Names' :[\n    \"JANE DOE\",\n    \" jane      doe\",\n    \"jane DOE\",\n    \"Sarah - Jane Doe \",\n    \"Sarah- Jane Doe\",\n    \"jane mcdoe\",\n    \"jane O'Doe\",\n]}\n\ndf = pd.DataFrame(data=messy_names)\n\ndf['Clean Names'] = df['Names'].apply(hh.format_name)\n\nprint(df.head(10))\n\n# Output\n#              Names     Clean Names\n#0          JANE DOE        Jane Doe\n#1     jane      doe        Jane Doe\n#3  Sarah - Jane Doe  Sarah-Jane Doe\n#2          jane DOE        Jane Doe\n#4   Sarah- Jane Doe  Sarah-Jane Doe\n#5        jane mcdoe      Jane McDoe\n#6        jane O'Doe      Jane O'Doe\n</code></pre>"},{"location":"names/#find-numbers-in-text","title":"Find Numbers in Text","text":"<p>This function takes text and returns True/False if one or more numbers is present (0-9). This can be useful for checking if numbers appear in names, either due to data entry error or because numbers have been added to names to differentiate students with the same name. You can use this function to check if names contain numbers before you attempt to remove then. This can be useful if a student has had a letter replaced by a number (e.g. zero for the letter O), and removing the numbers would leave the letter O missing. By checking first, you can confirm that it is safe to remove numbers. </p> <p>Info</p> <p>You can pass the <code>errors</code> argument to control error behaviour. Default is 'raise' which will raise all errors and stop your script. 'ignore' will not raise an error and return the original value. 'coerce' will not raise an error and return None.</p> <p>You can use the optional <code>convert_to_string</code> argument to set whether data passed to this function is converted to a string before the function runs.</p> Example with one nameExample with pandas DataFrame column <pre><code>import heat_helper as hh\n\nname_to_check = 'Jane Doe 23'\n\nis_numbers = hh.find_numbers_in_text(name_to_check)\n\nprint(f\"Are there numbers in '{name_to_check}'? Answer: {is_numbers}\")\n\n#Output: Are there numbers in 'Jane Doe 23'? Answer: True\n</code></pre> <pre><code>import heat_helper as hh\nimport pandas as pd\n\n# Example Data\n#  First Name   Last Name\n#       Jane   Hopper 23\n#       mike     Wheeler\n#    Lucas.     Sinclair\n#    Robin 1     Buckley\n#      st3ve  harrington\n#     dustin  HENDERSON\n#      nancY    wheeler\n\ndf['Numbers in First Name'] = df['First Name'].apply(hh.find_numbers_in_text)\ndf['Numbers in Last Name'] = df['Last Name'].apply(hh.find_numbers_in_text)\n\n#Output: \n#  First Name   Last Name  Numbers in First Name  Numbers in Last Name\n#       Jane   Hopper 23                  False                  True\n#       mike     Wheeler                  False                 False\n#    Lucas.     Sinclair                  False                 False\n#    Robin 1     Buckley                   True                 False\n#      st3ve  harrington                   True                 False\n#     dustin  HENDERSON                   False                 False\n#      nancY    wheeler                   False                 False\n</code></pre>"},{"location":"names/#remove-numbers","title":"Remove Numbers","text":"<p>This functions takes text and removes any numbers that are present (0-9). This can be useful for removing numbers from the end of names where you may have been provided data in the format 'Jane Doe 1', 'Jane Doe 2' to differentiate students with the same name. Typically, these numbers would not be added to records on the HEAT database, as other identifying information like date of birth or postcode can usually help you differentiate students in the database.</p> <p>Warning</p> <p>If a number has been used in place of a letter, this function will remove the number but cannot replace it with the letter it should represent. 'St3ve' will become 'Stve'. The <code>find_numbers_in_text</code> function can help you identify rows with numbers in them by allowed you to filter on 'True' to check what will be removed.</p> <p>The function will remove any number of numbers. Numbers do not have to be consecutive.</p> <p>Info</p> <p>You can pass the <code>errors</code> argument to control error behaviour. Default is 'raise' which will raise all errors and stop your script. 'ignore' will not raise an error and return the original value. 'coerce' will not raise an error and return None.</p> <p>You can use the optional <code>convert_to_string</code> argument to set whether data passed to this function is converted to a string before the function runs.</p> Example with one nameExample with pandas DataFrame column <pre><code>import heat_helper as hh\n\nname = 'Jane Doe 23'\n\nclean_name = hh.remove_numbers(name)\n\nprint(f\"Clean name is '{clean_name}'\")\n\n#Output: Clean name is 'Jane Doe'\n</code></pre> <pre><code>import heat_helper as hh\nimport pandas as pd\n\n# Example Data\n#  First Name   Last Name\n#       Jane   Hopper 23\n#       mike     Wheeler\n#    Lucas.     Sinclair\n#    Robin 1     Buckley\n#      st3ve  harrington\n#     dustin  HENDERSON\n#      nancY    wheeler\n\ndf['Clean First Name'] = df['First Name'].apply(hh.remove_numbers)\ndf['Clean in Last Name'] = df['Last Name'].apply(hh.remove_numbers)\n\n# Output\n#  First Name   Last Name Clean First Name Clean in Last Name\n#       Jane   Hopper 23             Jane             Hopper\n#       mike     Wheeler             mike            Wheeler\n#    Lucas.     Sinclair          Lucas.            Sinclair\n#    Robin 1     Buckley            Robin            Buckley\n#      st3ve  harrington             stve         harrington\n#     dustin  HENDERSON            dustin         HENDERSON\n#      nancY    wheeler             nancY           wheeler\n</code></pre>"},{"location":"names/#create-full-name","title":"Create Full Name","text":"<p>This function concatenates several strings into one string, typically for names. This is necessary if you want to carry out exact or fuzzy matching between names on a register and names in your HEAT Student export. You should create a full name column in both dataframes and use this for matching.</p> <p>Tip</p> <p>Middle names are optional. The function will run if you only have a first and last name string or column. Middle name functionality is included in case you use this field in HEAT.</p> Example with single stringsExample with pandas DataFrame columns <pre><code>import heat_helper as hh\n\nfirst = 'Jane'\nmiddle = 'Mary'\nlast = 'Doe'\n\nfull = hh.create_full_name(first, last)\nprint(full)\n\n#Output: Jane Doe\n\nfull = hh.create_full_name(first, last, middle_name=middle)\nprint(full)\n\n#Output: Jane Mary Doe\n</code></pre> <pre><code>import heat_helper as hh\nimport pandas as pd\n\nname_dict = {'First': ['Jane', 'Sarah', 'Jo'], \n         'Middle' : ['Rose', 'Louise', ''], \n         'Last' : ['Doe', 'Bloggs', 'McDonald']}\n\ndf = pd.DataFrame(name_dict)\n\ndf['Full Name'] = hh.create_full_name(\n    df['First'], \n    df['Last'], \n    middle_name=df['Middle'])\n\nprint(df.head())\n\n#   First  Middle      Last            Full Name\n#0   Jane    Rose       Doe        Jane Rose Doe\n#1  Sarah  Louise    Bloggs  Sarah Louise Bloggs\n#2     Jo          McDonald          Jo McDonald\n</code></pre>"},{"location":"names/#remove-diacritics","title":"Remove Diacritics","text":"<p>Attempts to remove diacritics (accented characters) from text and replace them with equivalent letters. Useful for normalising names before upload to HEAT or to improve exact and fuzzy matching responses.</p> <p>Info</p> <p>You can pass the <code>errors</code> argument to control error behaviour. Default is 'raise' which will raise all errors and stop your script. 'ignore' will not raise an error and return the original value. 'coerce' will not raise an error and return None.</p> Example with one nameExample with pandas DataFrame column <pre><code>import heat_helper as hh\n\ndiacritic = 'Chloe\u0308'\n\nclean = hh.remove_diacritics(diacritic)\n\nprint(f\"{diacritic} has been replaced with {clean}\")\n\n# Output: Chloe\u0308 has been replaced with Chloe\n</code></pre> <pre><code>import heat_helper as hh\nimport pandas as pd\n\n#Example data:\n#  First Name\n#      Ren\u00e9e\n#        Zo\u00eb\n#   Fran\u00e7ois\n#      Chlo\u00eb\n#       Si\u00e2n\n\ndf['Clean First Name'] = df['First Name'].apply(hh.remove_diacritics)\nprint(df)\n\n# Output:\n# First Name Clean First Name\n#      Ren\u00e9e            Renee\n#        Zo\u00eb              Zoe\n#   Fran\u00e7ois         Francois\n#      Chlo\u00eb            Chloe\n#       Si\u00e2n             Sian\n</code></pre>"},{"location":"names/#remove-punctuation","title":"Remove Punctuation","text":"<p>Attempts to remove punctuation except for hyphens and apostrophes from text. It initially replaces punctuation with spaces before replacing multiple spaces with one space, and trimming trailing and leading spaces. This means that if you have a name like <code>Jane...Doe</code> this function will clean it to <code>Jane Doe</code>. Useful for normalising/cleaning names before upload to HEAT or to improve exact and fuzzy matching responses.</p> <p>Info</p> <p>You can pass the <code>errors</code> argument to control error behaviour. Default is 'raise' which will raise all errors and stop your script. 'ignore' will not raise an error and return the original value. 'coerce' will not raise an error and return None.</p> Example with one nameExample with pandas DataFrame column <pre><code>import heat_helper as hh\n\npunctuation = 'Jane! Doe.'\n\nclean = hh.remove_punctuation(punctuation)\n\nprint(f\"{punctuation} has been replaced with {clean}\")\n\n# Output: Jane! Doe. has been replaced with Jane Doe\n</code></pre> <pre><code>import heat_helper as hh\nimport pandas as pd\n\n#Example data:\n#           Name\n#      Jane! Doe\n#  Jane O'Reilly\n#     \\Zoe Jones\n#  James...Smith\n#    Jane? Smith\n\ndf['Clean First Name'] = df['Name'].apply(hh.remove_punctuation)\nprint(df)\n\n#           Name Clean First Name\n#      Jane! Doe         Jane Doe\n#  Jane O'Reilly    Jane O'Reilly\n#     \\Zoe Jones        Zoe Jones\n#  James...Smith      James Smith\n#    Jane? Smith       Jane Smith\n</code></pre>"},{"location":"postcodes-doc/","title":"Postcodes API Reference","text":"<p>This is the API reference for all functions designed to be used on postcodes. You can find usage examples here.</p>"},{"location":"postcodes-doc/#heat_helper.postcode.format_postcode","title":"hh.format_postcode","text":"<pre><code>format_postcode(postcode: str, errors: str = 'raise') -&gt; str | None\n</code></pre> <p>Attempts to clean a postcode to conform to UK standard.</p> <p>Parameters:</p> Name Type Description Default <code>postcode</code> <code>str</code> <p>Text you want to clean.</p> required <code>errors</code> <code>str</code> <p>default = 'raise' which raises all errors. 'ignore' returns original value, 'coerce' attempts to turn postcode into string to run the function, if can't be run returns None.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised if postcode is not a string.</p> <code>InvalidPostcodeError</code> <p>Raised if postcode is not a valid length (5 to 7 chars).</p> <p>Returns:</p> Type Description <code>str | None</code> <p>Cleaned postcode.</p>"},{"location":"postcodes/","title":"Postcodes","text":"<p>These functions are designed to be run on postodes.</p>"},{"location":"postcodes/#format-postode","title":"Format Postode","text":"<p>This function takes a postcode, attempts to clean and format it in accordance to UK standards, and validate that it is a valid postcode form. The validation logic matches formats: A9 9AA, A99 9AA, AA9 9AA, AA99 9AA, A9A 9AA, AA9A 9AA. Postcodes will be returned with all uppercase letters, and a space between the outward and inward part.</p> <p>Errors will be raised if postcode is not a valid string (text) or if the format does not conform to the UK standard. You can ignore errors with <code>errors='ignore'</code> which will return the original postcode. You can also 'coerce' errors which will attempt to turn postcode into a string. If this still fails and raises an error, None will be returned.</p> <p>Warning</p> <p>This function does not validate that a UK postcode exists, only that it conforms to the expected format.</p> Example with list of postcodesExample on pandas dataframe <pre><code>import heat_helper as hh\n\npostcode_messy = ['aa11aa', 'w1a7nn', 'ST1 1AA', 'ST1', 'st5   5BG']\n\nclean_postcodes = [hh.format_postcode(postcode, errors='ignore') for \n                    postcode in postcode_messy]\n\nprint(clean_postcodes)\n\n#Output: ['AA1 1AA', 'W1A 7NN', 'ST1 1AA', 'ST1', 'ST5 5BG']\n</code></pre> <pre><code>import heat_helper as hh\nimport pandas as pd\n\npostcode_messy = ['aa11aa', 'w1a7nn', 'ST1 1AA', 'ST1', 'st5   5BG']\n\npostcode_dict = {'Postcodes' : postcode_messy}\n\npostcode_df = pd.DataFrame(postcode_dict)\n\npostcode_df['Clean Postcodes'] = postcode_df['Postcodes'].apply(\n    hh.format_postcode, errors='coerce'\n    )\n\nprint(postcode_df.head(5))\n\n#Output:\n#   Postcodes Clean Postcodes\n#0     aa11aa         AA1 1AA\n#2    ST1 1AA         ST1 1AA\n#1     w1a7nn         W1A 7NN\n#3        ST1            None\n#4  st5   5BG         ST5 5BG\n</code></pre>"},{"location":"road-map/","title":"Development","text":"<p><code>heat_helper</code> is in daily use by the development team and is likely to be updated frequently. Contributions or ideas for new functions are welcome; please get in touch via GitHub. </p> <p>The design philosophy for <code>heat_helper</code> is simple: the package should be as accessible as possible for users with limited python experience, or for beginners who are getting into python for the first time. For these users, functions should be easy to call, have robust error handling (with readable, easy-to-understand error messages), and cover a wide range of useful repetitive tasks they are likely to carry out with their data.</p> <p>Dependencies should also be limited to common data science libraries like <code>pandas</code>, <code>numpy</code>, and <code>pydantic</code>.</p>"},{"location":"updates-doc/","title":"Updates API Reference","text":"<p>This is the API reference for all functions for finding data which needs updating. You can find usage examples here.</p>"},{"location":"updates-doc/#heat_helper.updates.get_updates","title":"hh.get_updates","text":"<pre><code>get_updates(df: DataFrame, new_col: str, heat_col: str) -&gt; pd.Series\n</code></pre> <p>Compares two DataFrame columns and returns a value if new_col is different to heat_col. This can help you identify where new data is different to existing HEAT records and therefore needs updating. It returns a new column which only contains data that needs to be updated - so it can be copied to the HEAT import template. The original DataFrame is not modified; a copy is created internally.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame where the columns are located.</p> required <code>new_col</code> <code>str</code> <p>The column which contains 'new' data. This would be the data you want to update on HEAT if it differs from values in heat_col.</p> required <code>heat_col</code> <code>str</code> <p>The corresponding column in your HEAT export e.g. if you are checking if any postcodes need updating, both new_col and heat_col should contain postcodes.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised if df is not a DataFrame or new_col and heat_col are not strings (text).</p> <code>ColumnDoesNotExistError</code> <p>Raised if either new_col or heat_col are not in df columns.</p> <p>Returns:</p> Type Description <code>Series</code> <p>A pandas Series (DataFrame column) where rows contain the value from new_col if this is different to heat_col.</p>"},{"location":"updates-doc/#heat_helper.updates.get_contextual_updates","title":"hh.get_contextual_updates","text":"<pre><code>get_contextual_updates(\n    df: DataFrame,\n    new_col: str,\n    heat_col: str,\n    bad_values: Iterable[str],\n) -&gt; pd.Series\n</code></pre> <p>This function is similar to get_updates, except you can also pass a list, set, tuple or other Iterable of 'bad' values you do not want to override HEAT data. This can be useful if you want to ensure that data like 'Not available' or 'Unknown' does not overwrite previously collected 'good' values in the contextual data columns. The original DataFrame is not modified; a copy is created internally.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame where the columns are located.</p> required <code>new_col</code> <code>str</code> <p>The column which contains 'new' data. This would be the data you want to update on HEAT if it differs from values in heat_col.</p> required <code>heat_col</code> <code>str</code> <p>The corresponding column in your HEAT export e.g. if you are checking if any postcodes need updating, both new_col and heat_col should contain postcodes.</p> required <code>bad_values</code> <code>Iterable[str]</code> <p>A list, tuple, or set (or other Iterable) of values which should not overwrite 'good' data in your HEAT records. For example, if your new data contains 'Not available' or 'Unknown' but your HEAT records had values in these columns, you could pass ['Not available', 'Unknown'] to this variable, and these will not overwrite 'good' values in the heat_col.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised if df is not a DataFrame, new_col and heat_col are not strings (text), or bad_values is not a list.</p> <code>ColumnDoesNotExistError</code> <p>Raised if either new_col or heat_col are not in df columns.</p> <p>Returns:</p> Type Description <code>Series</code> <p>A pandas Series (DataFrame column) where rows contain the value from new_col if this is different to heat_col.</p>"},{"location":"updates/","title":"Updates","text":"<p>These functions are used to check if updates are required when matching data of new students to existing HEAT records. They return only the data that is different from your HEAT records, which can be copied to HEAT upload templates to bulk update records.</p>"},{"location":"updates/#get-updates","title":"Get Updates","text":"<p>This function compares two DataFrame columns and returns a value if <code>new_col</code> is different to <code>heat_col</code>. This can help you identify where new data is different to existing HEAT records and therefore needs updating. It returns a new column which only contains data that needs to be updated - so it can be copied to the HEAT import template.</p> <p>Note</p> <p>This function copies the original DataFrame in memory and does not modify your original DataFrame in place.</p> <p>For example, if you have collected new student data and matched this to your existing HEAT records and discover that some students already have records, you can use this function to check if the new data is different to the current records. If there are differences, the new data will be returned in the return column so that you can easily identify changes.</p> <p>Tip</p> <p>If used on string columns, it will attempt to 'normalise' nulls by filling them with blank strings and then turning them to None. This should mean that no null values are returned as 'new' data.</p> ExampleExample: running on multiple cols at once <pre><code>import heat_helper as hh\nimport pandas as pd\n\n# Example Data: we want to check if any postcodes in NEW Postcode \n# are different to the existing HEAT Postcodes\n#\n#       NEW Full Name NEW Postcode HEAT Postcode\n#            Jane Doe      BB1 1AB       AA1 1AA\n#          Mike Jones      BB2 2BB       BB2 2BB\n#        Thomas Smith                    CC3 3CC\n#         Sarah Brown      DD4 4DD       DD4 4DD\n#  Christopher Bloggs      AA1 1AA          None\n\ndf['Updated Postcodes'] = hh.get_updates(\ndf,\n'NEW Postcode',\n'HEAT Postcode'\n)\n\n# Result: Jane Doe's postcode needs updating, as does Christopher's \n# (which was blank on HEAT)\n#\n#       NEW Full Name NEW Postcode HEAT Postcode Updated Context\n#            Jane Doe      BB1 1AB       AA1 1AA         BB1 1AB\n#          Mike Jones      BB2 2BB       BB2 2BB            None\n#        Thomas Smith         None       CC3 3CC            None\n#         Sarah Brown      DD4 4DD       DD4 4DD            None\n#  Christopher Bloggs      AA1 1AA          None         AA1 1AA\n</code></pre> <pre><code>import heat_helper as hh\nimport pandas as pd\n\npersonal_columns_to_update = [\n\"First Name\",\n\"Middle Name\",\n\"Last Name\",\n\"Date of Birth\",\n\"Home Postcode\",\n\"Last known Institution HEAT ID\",\n\"Last known Institution Name\",\n\"Individual Data Collection Date\",\n\"Individual Data Collection Privacy Form\",\n\"Phase Adjustment\",\n]\n\n# Update person cols if new data is different to old\nfor col in personal_columns_to_update:\n    heat_col = f\"HEAT: {col}\"\n    update_col = f\"Update: {col}\"\n    df[update_col] = hh.get_updates(df, col, heat_col)\n\n# This would create a new column for each column in personal_columns_to_update \n# containing only data that needs updating\n</code></pre>"},{"location":"updates/#get-contextual-updates","title":"Get Contextual Updates","text":"<p>This function compares two DataFrame columns and returns a value if <code>new_col</code> is different to <code>heat_col</code> and if the values in <code>new_col</code> are not in <code>bad_values</code>. This can help you identify where new data is different to existing HEAT records and therefore needs updating, but will not override 'good' data with values like 'Not available' 'Unknown' or 'Information Refused'. It returns a new column which only contains data that needs to be updated - so it can be copied to the HEAT import template.</p> <p>For example, if you have collected new student data and matched this to your existing HEAT records and discover that some students already have records, you can use this function to check if the new data is different to the current records. If there are differences, the new data will be returned in the return column so that you can easily identify changes.</p> <p>Note</p> <p>This function copies the original DataFrame in memory and does not modify your original DataFrame in place.</p> <p>The best use case for this function is on the contextual data columns in the HEAT Student Export, as you can pass all 'bad' values as a list, tuple, set or any other Iterable and avoid them overwriting older data.</p> <p>Tip</p> <p>If used on string columns, it will attempt to 'normalise' nulls by filling them with blank strings and then turning them to None. This should mean that no null values are returned as 'new' data.</p> ExampleExample: running on multiple cols at once <pre><code>import heat_helper as hh\nimport pandas as pd\n\n# Example Data: we want to check if any values in NEW Context \n# are different to the existing HEAT Context, but we don't want\n# values like 'Not available' or 'Information Refused' to overwrite \n# 'good' values like 'Yes' and 'No'.\n#\n#       NEW Full Name          NEW Context HEAT Context\n#            Jane Doe        Not available          Yes\n#          Mike Jones  Information Refused           No\n#        Thomas Smith                  Yes           No\n#         Sarah Brown                                No\n#  Christopher Bloggs                  Yes          Yes\n\ndf['Updated Context'] = hh.get_contextual_updates(\ndf,\n'NEW Context',\n'HEAT Context',\nbad_values = ['Not available', 'Information Refused']\n)\n\n# Result: only Thomas Smith's Context needs updating\n#\n#       NEW Full Name          NEW Context HEAT Context Updated Context\n#            Jane Doe        Not available          Yes            None\n#          Mike Jones  Information Refused           No            None\n#        Thomas Smith                  Yes           No             Yes\n#         Sarah Brown                 None           No            None\n#  Christopher Bloggs                  Yes          Yes            None\n</code></pre> <pre><code>import heat_helper as hh\nimport pandas as pd\n\n# Define the \"bad\" values we do not want to be overridden \n# by good values (lose no data via updates)\nBAD_VALUES = (\n\"Not available\",\n\"Information refused\",\n\"Not available (999)\",\n\"Unknown\",\n\"Not known (997)\",\n\"Prefer not to say (998)\",\n\"Prefer not to say\",\n)\n\ncontextual_columns_to_update = [\n\"Sex\",\n\"First Generation HE\",\n\"Disability\",\n\"Ethnicity\",\n\"Refugee / Asylum Seeker\",\n\"Care Leaver\",\n\"Estranged\",\n\"Service Children\",\n\"Young Carer\",\n]\n\n# Update contextual only if new data is different AND 'good'\nfor col in contextual_columns_to_update:\n    left_col = col\n    heat_col = f\"HEAT: {col}\"\n    update_col = f\"Update: {col}\"\n\n    # Create all cols in the list\n    df[update_col] = hh.get_contextual_updates(df, \n                            left_col, heat_col, BAD_VALUES)\n\n# This would create a new column for each column in \n# contextual_columns_to_update containing only data that needs \n# updating\n</code></pre>"},{"location":"validation-doc/","title":"Validation API Reference","text":"<p>This is the API reference for all functions designed to be used for validation. You can find usage examples here.</p>"},{"location":"validation-doc/#heat_helper.validation.create_error_report","title":"hh.create_error_report","text":"<pre><code>create_error_report(\n    df: DataFrame, Model: Any, df_name: str\n) -&gt; pd.DataFrame\n</code></pre> <p>Uses a Pydantic model to validate each row of a DataFrame and generates an error report.  Returns the original DataFrame with three new columns: 'val_error_count', 'val_error_details', and 'validation_status'.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame you want to validate.</p> required <code>Model</code> <code>Any</code> <p>Your pydantic model. Should be a subclass of BaseModel.</p> required <code>df_name</code> <code>str</code> <p>Name of your DataFrame for logging purposes.</p> required <p>Raises:</p> Type Description <code>ImportError</code> <p>Raised if pydantic is not installed</p> <code>TypeError</code> <p>Raised if df is not a DataFrame or Model is not a Pydantic BaseModel class. </p> <code>AttributeError</code> <p>Raised if Model does not have 'model_validate' method (ensures you are using Pydantic v2).</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Your original DataFrame with three new columns: 'val_error_count': Number of validation errors in the row (0 if valid); 'val_error_details': A string summarising the validation errors (None if valid);'validation_status': \"Valid\" or \"Invalid\"</p>"},{"location":"validation/","title":"Validation","text":"<p>These functions are used with the optional <code>pydantic</code> dependency to validate your data and generate error reports.</p> <p>Info</p> <p>To install <code>heat_helper</code> with the optional <code>pydantic</code> dependency use:</p> <pre><code>pip install heat_helper[validation]\n</code></pre>"},{"location":"validation/#create-error-report","title":"Create Error Report","text":"<p>This function allows you to validate a DataFrame against a <code>pydantic</code> Model and returns the DataFrame with information about the number and type of errors found per row. It will return any 'extra' data passed to the Model (usually columns in the DataFrame which do not correspond to a field in the Model and so are not validated) in the DataFrame, but obviously these columns won't have been validated. Pydantic by default usually removes any extra data passed to a Model, so this behaviour is different to the standard but has been included as it is less destructive. </p> Example: Activity Register <pre><code>import heat_helper as hh \nimport pandas as pd \nfrom pydantic import BaseModel, Field\nfrom datetime import date\nfrom typing import Literal\n\n# DEFINE YOUR PYDANTIC VALIDATION MODEL. \n# This is a Validation Model for activity registers.\nclass Register(BaseModel):\n    first_name: str\n    last_name: str\n    date_of_birth: date = Field(le=date(2014,8,31))\n    postcode: str = Field(min_length=6, max_length=8)\n    year_group: Literal['Year 7', 'Year 8', 'Year 9', \n                        'Year 10', 'Year 11', \n                        'Year 12', 'Year 13']\n    school: str\n    attended: Literal['Y', 'N']\n\n# LOAD DATA AND CREATE ERROR REPORT\nregister = pd.read_csv('register.csv')\n\nerror_report = create_error_report(register, Register, 'register')\n\nprint(error_report.head(15))  \n\n# RETURNED DATAFRAME - VALIDATION COLUMNS \n# (Note: original data ommitted but would also be returned.)\n#\n# Validated 14 rows in register. 4 rows have 4 total errors.\n#    val_error_count                                  val_error_details validation_status\n#0                 0                                               None             Valid\n#1                 0                                               None           Invalid\n#2                 1      'date_of_birth': Input should be a valid date           Invalid\n#4                 0                                               None             Valid\n#3                 0                                               None             Valid\n#5                 1  'postcode': String should have at least 6 char...           Invalid\n#6                 1           'school': Input should be a valid string           Invalid\n#7                 0                                               None             Valid\n#8                 0                                               None             Valid\n#9                 0                                               None             Valid\n#10                0                                               None             Valid\n#11                0                                               None             Valid\n#12                1         'postcode': Input should be a valid string           Invalid\n</code></pre>"},{"location":"year-groups-doc/","title":"Year Groups API Reference","text":"<p>This is the API reference for all functions designed to be used on year groups. You can find usage examples here.</p>"},{"location":"year-groups-doc/#heat_helper.yeargroup.clean_year_group","title":"hh.clean_year_group","text":"<pre><code>clean_year_group(\n    year_group: str | int, errors: str = \"raise\"\n) -&gt; str | None\n</code></pre> <p>Takes school year groups and cleans them to have the consistent format 'Year i'.</p> <p>Parameters:</p> Name Type Description Default <code>year_group</code> <code>str | int</code> <p>Text you wish to clean. Numbers entered will be cast to strings if possible.</p> required <code>errors</code> <code>str</code> <p>default = 'raise' which raises all errors. 'ignore' returns original value, 'coerce' returns None.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>InvalidYearGroupError</code> <p>Raised when <code>year group</code> input cannot be parsed or is out of range.</p> <code>TypeError</code> <p>Raised when <code>year group</code> input cannot be parsed to a valid int.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>Cleaned year group in the format 'Year i'.</p>"},{"location":"year-groups-doc/#heat_helper.yeargroup.calculate_year_group_from_date","title":"hh.calculate_year_group_from_date","text":"<pre><code>calculate_year_group_from_date(\n    input_date: date,\n    start_of_academic_year: int = CURRENT_ACADEMIC_YEAR_START,\n    errors: str = \"raise\",\n) -&gt; str | None\n</code></pre> <p>Calculates school year group from date of birth for the English school system. Returns 'Year i' or 'Reception', or 'Student too young for school' if date of birth is not of school age.</p> <p>Parameters:</p> Name Type Description Default <code>input_date</code> <code>date</code> <p>Date of birth you wish to know the school year for.</p> required <code>start_of_academic_year</code> <code>optional</code> <p>The school year in which you want to calculate the year group for. Allows you to calculate a year group for any academic year not just current e.g. for 2025/26 school year enter 2025. Default is start of current academic year.</p> <code>CURRENT_ACADEMIC_YEAR_START</code> <code>errors</code> <code>optional</code> <p>default = 'raise' which raises all errors. 'ignore' returns None.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised if input_date is not a date.</p> <code>InvalidYearGroupError</code> <p>Raised when the calculated year group is out of range (greater than Year 13).</p> <p>Returns:</p> Type Description <code>str | None</code> <p>Returns 'Year i', 'Reception', 'Student too young for school' or None if errors='ignore'.</p>"},{"location":"year-groups/","title":"Year Groups","text":"<p>These functions are for use with year groups.</p>"},{"location":"year-groups/#clean-year-group","title":"Clean Year Group","text":"<p>This function is designed to standardise the way that year groups appear in your data. Year Groups (1-13) are formatted to: 'Year i' or 'Reception'. It will also raise an error if a year group is not within the range 0 (Reception) to 13. </p> <p>Error Warning</p> <p>This function cannot clean FE Levels. It will raise <code>FELevelError</code> error if FE Levels are entered, or <code>InvalidYearGroupError</code> if a Year Group is outside of the expected range (0-13) is entered. If <code>errors</code> are ignored, the original value is returned. You can set <code>error</code> behaviour using the errors argument.</p> Example on listExample on pandas DataFrame <pre><code>import heat_helper as hh\n\nyear_group_messy = ['Year 10', 'Y9', 10, 'year 11', 'reception', 'year r']\n\nclean_year_groups = [hh.clean_year_group(yg, errors='ignore') \n                        for yg in year_group_messy]\n\nprint(clean_year_groups)\n\n# Output: ['Year 10', 'Year 9', 'Year 10', 'Year 11', 'Reception', 'Reception']\n</code></pre> <pre><code>import heat_helper as hh\nimport pandas as pd\n\nyear_group_messy = ['Year 10', 'Y9', 10, 'year 11', 'reception', 'year r']\n\nyg_dict = {'Year Group' : year_group_messy}\n\nyg_df = pd.DataFrame(yg_dict)\n\nyg_df['Clean YG'] = yg_df['Year Group'].apply(hh.clean_year_group)\n\nprint(yg_df.head(6))\n\n# Output\n#  Year Group   Clean YG\n#0    Year 10    Year 10\n#1         Y9     Year 9\n#2         10    Year 10\n#3    year 11    Year 11\n#4  reception  Reception\n#5     year r  Reception\n</code></pre>"},{"location":"year-groups/#calculate-year-group-from-date","title":"Calculate Year Group from Date","text":"<p>This function calculates which year group a date of birth falls into. Useful for checking students are in the year group you have been told (e.g. by the student or by the school), and then calculating a Phase Adjustment value if necessary. Year group is calculated for the current academic year. This can be overridden using the <code>start_year</code> argument to calculate which year group students would have been in in previous academic years. See API documentation. </p> <p>Year groups are returned in the format 'Year i' except for Reception which is returned as 'Reception'. If errors are ignored for this funtion, None is returned.</p> <p>Warning</p> <p>Calculating a year group from a date of birth is not always correct - some students may not be in the 'correct' year group for their date of birth for a variety of reasons. This might particularly be the case at post-16 level or for students with dates of birth in August, who sometimes start school the following year.</p> <p>This function will only return Reception to Year 13. If a student is too young for school, 'Student too young for school' will be returned. If a student is too old for school, an <code>InvalidYearGroupError</code> will be returned, unless errors are ignored in which case None is returned.</p> Example with single dateExample on pandas DataFrame <pre><code>import heat_helper as hh\nfrom datetime import date\n\ndate_yg = date(2011, 1, 2)\n\nyear_group = hh.calculate_year_group_from_date(date_yg)\n\nprint(f\"Date: {date_yg} is in {year_group}\")\n\n# Output:\n# Date: 2011-01-02 is in Year 10\n</code></pre> <pre><code>import heat_helper as hh\nimport pandas as pd\nfrom datetime import date\n\ndate_dict = {'Date of birth' : \n    [date(2013, 9, 1), \n    date(2013, 7, 25), \n    date(2014, 2, 20), \n    date(2010, 9, 1)]}\n\ndate_df = pd.DataFrame(date_dict)\n\ndate_df['Year Group'] = date_df['Date of birth']\n    .apply(hh.calculate_year_group_from_date)\n\nprint(date_df)\n\n# Output:\n#  Date of birth Year Group\n#0    2013-09-01     Year 7\n#1    2013-07-25     Year 8\n#2    2014-02-20     Year 7\n#3    2010-09-01    Year 10\n</code></pre>"}]}